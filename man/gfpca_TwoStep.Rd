% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gfpca_TwoStep.R
\name{gfpca_TwoStep}
\alias{gfpca_TwoStep}
\title{gfpca_TwoStep}
\usage{
gfpca_TwoStep(data, npc = NULL, pve = 0.9, output_index = NULL,
  type = c("approx", "naive", "fixed"), basis = NULL, nbasis = 10)
}
\arguments{
\item{data}{A dataframe containing observed data. Should have column names
\code{index} for observation times, \code{value} for observed responses,
and \code{id} for curve indicators.}

\item{npc}{prespecified value for the number of principal components (if
given, this overrides \code{pve}).}

\item{pve}{proportion of variance explained; used to choose the number of
principal components.}

\item{output_index}{Grid on which estimates should be computed. Defaults to
\code{NULL} and returns estimates on the timepoints in the observed dataset}

\item{type}{Type of estimate for the FPCs; either \code{approx} or
\code{naive}}

\item{basis}{Basis used as FPCs; in simulations, allows the use of the true
FPCs}

\item{nbasis}{Number of basis functions used in spline expansions}
}
\description{
Implements a two-step approach to generalized functional principal
components analysis for sparsely observed binary curves
}
\examples{

\dontrun{
library(mvtnorm)
library(boot)
library(refund.shiny)

## set simulation design elements

bf = 10                           ## number of bspline fns used in smoothing the cov
D = 101                           ## size of grid for observations
Kp = 2                            ## number of true FPC basis functions
grid = seq(0, 1, length = D)

## sample size and sparsity
I <- 300
mobs <- 7:10

## mean structure
mu <- 8*(grid - 0.4)^2 - 3

## Eigenfunctions /Eigenvalues for cov:
psi.true = matrix(NA, 2, D)
psi.true[1,] = sqrt(2)*cos(2*pi*grid)
psi.true[2,] = sqrt(2)*sin(2*pi*grid)

lambda.true = c(1, 0.5)

## generate data

set.seed(1)

## pca effects: xi_i1 phi1(t)+ xi_i2 phi2(t)
c.true = rmvnorm(I, mean = rep(0, Kp), sigma = diag(lambda.true))
Zi = c.true \%*\% psi.true

Wi = matrix(rep(mu, I), nrow=I, byrow=T) + Zi
pi.true = inv.logit(Wi)  # inverse logit is defined by g(x)=exp(x)/(1+exp(x))
Yi.obs = matrix(NA, I, D)
for(i in 1:I){
  for(j in 1:D){
    Yi.obs[i,j] = rbinom(1, 1, pi.true[i,j])
  }
}

## "sparsify" data
for (i in 1:I)
{
  mobsi <- sample(mobs, 1)
  obsi <- sample(1:D, mobsi)
  Yi.obs[i,-obsi] <- NA
}

Y.vec = as.vector(t(Yi.obs))
subject <- rep(1:I, rep(D,I))
t.vec = rep(grid, I)

data.sparse = data.frame(
  index = t.vec,
  value = Y.vec,
  id = subject
)

data.sparse = data.sparse[!is.na(data.sparse$value),]

## fit models

# 2-step with eigenfunctions from FPCA
fit.2step = gfpca_TwoStep(data = data.sparse, type="naive")
plot(mu)
lines(fit.2step$mu, col=2)

# 2-step with eigenfunctions estimated following Hall et al. (2008)
fit.2step = gfpca_TwoStep(data = data.sparse, type="approx")
plot(mu)
lines(fit.2step$mu, col=2)
plot_shiny(fit.2step)

}

}
\author{
Jan Gertheiss \email{jan.gertheiss@agr.uni-goettingen.de}
}
\references{
Gertheiss, J., Goldsmith, J., and Staicu, A.-M. (2016). A note
on modeling sparse exponential-family functional response curves.
\emph{Under Review}.
}
\seealso{
\code{\link{gfpca_TwoStep}}, \code{\link{gfpca_Bayes}}.
}


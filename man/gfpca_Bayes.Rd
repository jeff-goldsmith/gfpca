% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gfpca_Bayes.R
\name{gfpca_Bayes}
\alias{gfpca_Bayes}
\title{gfpca_Bayes}
\usage{
gfpca_Bayes(data, npc = 3, grid = NULL, nbasis = 10, iter = 1000,
  warmup = 400)
}
\arguments{
\item{data}{A dataframe containing observed data. Should have column names \code{.index} 
for observation times, \code{.value} for observed responses, and \code{.id} for curve
indicators.}

\item{npc}{Number of FPC basis functions to estimate}

\item{grid}{Grid on which estimates should be computed. Defaults to \code{NULL} and returns
estimates on the timepoints in the observed dataset}

\item{nbasis}{Number of basis functions used in spline expansions}

\item{iter}{Number of sampler iterations}

\item{warmup}{Number of iterations discarded as warmup}
}
\description{
Implements a Bayesian approach to generalized functional principal components analysis for 
sparsely observed binary curves
}
\examples{
\dontrun{
library(mvtnorm)
library(boot)

## set simulation design elements

bf = 10                           ## number of bspline fns used in smoothing the cov
D = 101                           ## size of grid for observations
Kp = 2                            ## number of true FPC basis functions
grid = seq(0, 1, length = D)

## sample size and sparsity
I <- 300
mobs <- 7:10

## mean structure
mu <- 8*(grid - 0.4)^2 - 3

## Eigenfunctions /Eigenvalues for cov:
psi.true = matrix(NA, 2, D)
psi.true[1,] = sqrt(2)*cos(2*pi*grid)
psi.true[2,] = sqrt(2)*sin(2*pi*grid)

lambda.true = c(1, 0.5)

## generate data

set.seed(1)

## pca effects: xi_i1 phi1(t)+ xi_i2 phi2(t)
c.true = rmvnorm(I, mean = rep(0, Kp), sigma = diag(lambda.true))
Zi = c.true \%*\% psi.true

Wi = matrix(rep(mu, I), nrow=I, byrow=T) + Zi
pi.true = inv.logit(Wi)  # inverse logit is defined by g(x)=exp(x)/(1+exp(x))
Yi.obs = matrix(NA, I, D)
for(i in 1:I){
  for(j in 1:D){
    Yi.obs[i,j] = rbinom(1, 1, pi.true[i,j])
  }
}

## "sparsify" data
for (i in 1:I)
{
  mobsi <- sample(mobs, 1)
  obsi <- sample(1:D, mobsi)
  Yi.obs[i,-obsi] <- NA
}

Y.vec = as.vector(t(Yi.obs))
subject <- rep(1:I, rep(D,I))
t.vec = rep(grid, I)

data.sparse = data.frame(
  .index = t.vec,
  .value = Y.vec,
  .id = subject
)

data.sparse = data.sparse[!is.na(data.sparse$.value),]

## fit Bayesian models
fit.Bayes = gfpca_Bayes(data = data.sparse)
plot(mu)
lines(fit.Bayes$mu, col=2)

}
}
\author{
Jan Gertheiss \email{jan.gertheiss@agr.uni-goettingen.de}
}
\references{
Gertheiss, J., Goldsmith, J., and Staicu, A.-M. (2016).
A note on modeling sparse exponential-family functional response curves. 
\emph{Under Review}.
}

